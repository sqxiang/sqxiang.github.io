---
title: 哈夫曼树
date: 2016-04-28 19:44:43
tags: 
 - 数据结构
 - 二叉树
 - 哈夫曼树
categories: 数据结构
---
<blockquote class="blockquote-center">哈夫曼树</blockquote>
<!-- more -->
　　哈夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树。所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度（若根结点为0层，叶结点到根结点的路径长度为叶结点的层数）。树的带权路径长度记为
$$WPL=(W1*L1+W2*L2+W3*L3+...+Wn*Ln)$$，N个权值$Wi(i=1,2,...n)$构成一棵有N个叶结点的二叉树，相应的叶结点的路径长度为$Li(i=1,2,...n)$可以证明哈夫曼树的WPL是最小的。
　　根据哈弗曼树的定义，一棵二叉树要使其WPL值最小，必须使权值越大的叶子结点越靠近根结点，而权值越小的叶子结点越远离根结点。
　　哈夫曼编码步骤：

　　一、对给定的n个权值${W1,W2,W3,...,Wi,...,Wn}$构成n棵二叉树的初始集合$F= {T1,T2,T3,...,Ti,...,Tn}$，其中每棵二叉树$Ti$中只有一个权值为$Wi$的根结点，它的左右子树均为空。（为方便在计算机上实现算法，一般还要求以$Ti$的权值$Wi$的升序排列。）
　　二、在$F$中选取两棵根结点权值最小的树作为新构造的二叉树的左右子树，新二叉树的根结点的权值为其左右子树的根结点的权值之和。
　　三、从$F$中删除这两棵树，并把这棵新的二叉树同样以升序排列加入到集合$F$中。
　　四、重复二和三两步，直到集合F中只有一棵二叉树为止。 
　　比如我们现在有$A,B,C,D,E$五个结点，每个的权值（哈夫曼编码中指出现频率）为５，４，３，２，１，那么每一步取最小的两个权值向上生长即可，第一步取２和１，如下图:
![](/img/huff1.png)
　　虚线为新生成的结点，第二步再把新生成的权值为3的结点放到剩下的集合中，所以集合变成{5,4,3,3}，再根据第二步，取最小的两个权值构成新树，如图：
![](/img/huff2.png)
　　再依次建立哈夫曼树，如下图： 
![](/img/huff3.jpg)
　　如果要对字符进行哈夫曼编码，则规定哈夫曼树中所有左分支表示字符0，所有右分支表示字符1,将依次从根结点到每个叶子结点所经过的分支的二进制位的序列作为该结点对应的字符编码。
　　由于从根结点到任何一个叶子结点都不可能经过其他叶子，这种编码一定是前缀编码，哈夫曼树的带权路径长度正好是文件编码的总长度。
　　什么是带权路径长度，我们可以有如下定义：
**路径： 树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。
路径长度：路径上的分枝数目称作路径长度。
树的路径长度：从树根到每一个结点的路径长度之和。
结点的带权路径长度：在一棵树中，如果其结点上附带有一个权值，通常把该结点的路径长度与该结点上的权值                                       之积称为该结点的带权路径长度（weighted path length）**
　　编码后的哈夫曼树如下:
 ![](/img/huff4.jpg)
　　则各字符对应的编码为：$A->11,B->10,C->00,D->011,E->010$
　　霍夫曼编码是一种前缀编码。解码时不会混淆。其主要应用在数据压缩，加密解密等场合。 
源代码如下:
{% codeblock lang:python %}
　class Node(object):
    　def __init__(self,parent=None,lchild=None,rchild=None,weight=0,ch=None):
        　self.parent=parent
        　self.lchild=lchild
        　self.rchild=rchild
        　self.weight=weight
        　self.ch = ch

　def createNodes(Ht):
    　return [Node(weight=value,ch=key) for key,value in Ht.iteritems()]

　def huffman(ht):
    　htNodes = createNodes(ht)
    　nodes = htNodes[:]
    　while len(nodes)>1:
        　nodes.sort(key=lambda x:x.weight)
        　m1 = nodes.pop(0)
        　m2 = nodes.pop(0)
        　p = Node(weight=m1.weight+m2.weight)
        　p.lchild = m1
        　p.rchild = m2
        　m1.parent,m2.parent = p,p
        　nodes.append(p)
    　root = nodes[0]
    　return htNodes,root

　def huffcode(ht):
    　nodes,root = huffman(ht)
    　n = len(nodes)
    　codes = ['']*n
    　for i in range(n):
        　tmp_node = nodes[i]
        　while tmp_node != root:
            　if tmp_node.parent.lchild == tmp_node:
                　codes[i] = '0' + codes[i]
            　else:
                　codes[i] = '1' + codes[i]
            　tmp_node = tmp_node.parent
    　return codes
{% endcodeblock %}
或者:
{% codeblock lang:python %}
from heapq import heapify, heappush, heappop
from itertools import count

def huffman(seq, frq):
    num = count()
    trees = list(zip(frq, num, seq))            # num ensures valid ordering
    heapify(trees)                              # A min-heap based on freq
    while len(trees) > 1:                       # Until all are combined
        fa, _, a = heappop(trees)               # Get the two smallest trees
        fb, _, b = heappop(trees)
        n = next(num)
        heappush(trees, (fa+fb, n, [a, b]))     # Combine and re-add them
    # print trees
    return trees[0][-1]

seq = "abcdefghi"
frq = [4, 5, 6, 9, 11, 12, 15, 16, 20]
print huffman(seq, frq)
{% endcodeblock %}

