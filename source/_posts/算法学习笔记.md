---
title: 算法学习笔记
date: 2016-04-13 23:10:48
tags:
 -快速排序
 -舍伍德算法
categories: 算法
---
<blockquote class="blockquote-center">算法</blockquote>
<!--more-->
## 序
这个系列纯粹是为了记载那些很普通的算法，一方面个人确实很渣，本科没好好学习，现在才苦于连基础的算法都不太了解，因此强迫自己把那些早该看的算法再从头学一遍。算法顺序不是按难易来的，大概是个人心血来潮想到就会来写一点吧。
从来就没有太迟，现在就是最好的开始。

### 蒙特卡洛，拉斯维加斯，数值概率，舍伍德算法
### 快速排序
{% codeblock lang:Python %}
    class Solution(object):
        def partition(self,a,p,r):
            i,j = p+1,r
            q = a[p]
            while(True):
                while(i<r and a[i]<q):
                    i+=1
                while(a[j]>q):
                    j-=1
                if(i>=j):break
                a[i],a[j]=a[j],a[i]
            a[p]=a[j]
            a[j]=q
            return j
        def qSort(self,a,p,r):
            if(p<r):
                q = self.partition(a,p,r)
                self.qSort(a,p,q-1)
                self.qSort(a,q+1,r)
 {% endcodeblock %}
 思想比较简单，找一个基准值，把小于它的放左边，大于它的放右边，然后递归左右两边。因为是就地进行，结束递归也就排好序了。一般找数组第一个作为基准值，因为找最后一个若是它最大会出问题。若是随机选取基准值，就变成了舍伍德型算法。
 ```python
        def randomizePartition(self,a,p,r):
            i = random.randint(p,r)
            a[i],a[p] = a[p],a[i]
            return self.partition(a,p,r)
        def randomQuickSort(self,a,p,r):
            if(p<r):
                q = self.randomizePartition(a,p,r)
                randomQuickSort(a,p,q-1)
                randomQuickSort(a,q+1,r)
    ```
快速排序最大复杂度O(n^2),平均复杂度O(nlgn)

### 线性时间选择算法(选择第k小的数)
{% codeblock lang:python %}
    def randomSelect(self,a,p,r,k):
        i = self.randomizePartition(a,p,r)
        j = i-p+1
        if(k<=j):
            return self.randomSelect(a,p,i,k)
        else:
            return self.randomSelect(a,i+1,r,k-j)
{% endcodeblock %}
利用随机划分把小的和大的分开，如果k比小的部分长度小，则在小的部分递归寻找，如果大于小的部分长度，则在大的部分递归寻找。



